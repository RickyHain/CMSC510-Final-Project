# CMSC510-Final-Project

  I chose to do the Sudoku Solver backtracking problem from LeetCode. The task is pretty straightforward, given a partially-filled, standard Sudoku board with only one possible answer, use back tracking to find the solution. The only real-world applications of this problem would have to be related to Sudoku. Maybe youâ€™re making a website that provides Sudoku solutions or hints. Regardless, I chose this problem because the objective was clear, and it seemed like a fun challenge.
  
  To start this project, I thought about how I would normally solve a Sudoku problem. I first identified three basic patterns that are used to check which numbers can be placed into each cell: checking the row, the column, and the square. I then thought about how sometimes these approaches are not enough to solve a Sudoku problem, and that you need to identify other patterns in order to find the correct solution without just guessing. This initially made me very confused as to how I was going to account for all of these alternative patterns, until I remembered the purpose of using a back-tracking approach.  With back-tracking, I am able to essentially brute force all possibilities up to the point where I find a cell that is impossible to fill, and once I reach that point, I can just explore another branch. I can then repeat this until I find the solution.
  
  I started off programming by making a function that returns a vector of all possible values a given cell can be. The 2D vector, used to represent the board, stores all of the values as characters instead of integers. This caused me to use an overcomplicated approach of converting chars to ints, until I realized that it was unnecessary and that the logic operators are functionally the same for comparing characters. I went online to find a quick way to remove elements from a vector using their value opposed to their index, and found a Stack Overflow forum that showcases the vector.erase() and vector.remove() functions.
  
  The final issue I had with the project came from the solveSudoku(vector<vector<char>> &board) function. Given the code provided by LeetCode, you pass in the Sudoku board as a reference. This became a problem for me, as every time I explored a new branch of possible solutions, the previously filled-in-values would remain upon testing the next branch and mess everything up. I thought of two ways to go about this, I could either have the solveSudoku() function call another function that would take the board in as a copy and find the solution and then update the referenced board, or I could take the board in as a copy and simply print out the solution. I ultimately decided to do the latter because I felt that both approaches demonstrated my understanding of back tracking the same and that the other option was needlessly more complicated.
